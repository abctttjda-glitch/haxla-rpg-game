<script>
/* ===== 武器 ===== */
function generateWeapon(){
  const r = Math.random();
  let rarity = "N", mult = 1;

  if(r > 0.98){ rarity="L"; mult=3; }
  else if(r > 0.90){ rarity="E"; mult=2; }
  else if(r > 0.70){ rarity="R"; mult=1.5; }

  return {
    rarity,
    atk: Math.floor(5 * mult),
    crit: 0.05 * mult
  };
}

/* ===== キャラ ===== */
class Character {
  constructor() {
    this.level = 1;
    this.exp = 0;
    this.maxHp = 100;
    this.hp = this.maxHp;
    this.atk = 10;
    this.def = 5;
    this.alive = true;
    this.weapon = generateWeapon();
    this.skill = Math.random() < 0.3 ? "連撃" : "強撃";
  }
}

/* ===== 敵 ===== */
class Enemy {
  constructor(dist) {
    let mult = 1;
    if(dist % 100 === 0) mult = 5;
    else if(Math.random() < 0.2) mult = 2;

    this.maxHp = Math.floor((50 + dist*0.5) * mult);
    this.hp = this.maxHp;
    this.atk = Math.floor((5 + dist*0.05) * mult);
    this.def = Math.floor(dist*0.02 * mult);
  }
}

/* ===== 状態 ===== */
let distance = 0;
let rebirthCount = 0;
let speed = 1;
let autoTimer = null;
let currentEnemy = null;
let party = Array.from({ length: 5 }, () => new Character());

/* ===== 成長 ===== */
function expToNextLevel(lv){
  return Math.floor(20 * Math.pow(lv,1.6));
}
function rand(min,max){
  return Math.floor(Math.random()*(max-min+1))+min;
}
function levelUp(c){
  c.level++;
  c.maxHp += rand(10,15);
  c.atk += rand(2,4);
  c.def += rand(1,2);
  c.hp = c.maxHp;
}
function addExp(c,val){
  c.exp += val;
  while(c.exp >= expToNextLevel(c.level)){
    c.exp -= expToNextLevel(c.level);
    levelUp(c);
  }
}

/* ===== バトル ===== */
function calcDamageWithSkill(c, enemy){
  let atk = c.atk + c.weapon.atk;

  if(Math.random() < c.weapon.crit) atk *= 2;
  if(c.hp / c.maxHp <= 0.5) atk *= 2;

  return Math.max(1, Math.floor(atk - enemy.def));
}

function randomAlive(){
  const a = party.filter(c=>c.alive);
  return a[Math.floor(Math.random()*a.length)];
}

function reviveParty(){
  party.forEach(c=>{
    c.alive=true;
    c.hp=c.maxHp;
  });
}

function battle(enemy,end){
  const it=setInterval(()=>{
    for(const c of party){
      if(!c.alive) continue;

      let hits = (c.skill==="連撃" && Math.random()<0.3) ? 2 : 1;
      for(let i=0;i<hits;i++){
        enemy.hp -= calcDamageWithSkill(c, enemy);
        if(enemy.hp<=0) break;
      }
      if(enemy.hp<=0) break;
    }

    updateEnemyUI();

    if(enemy.hp<=0){
      clearInterval(it);
      party.forEach(c=>c.alive && addExp(c,10));
      reviveParty();
      end();
      return;
    }

    const t=randomAlive();
    t.hp -= Math.max(1, enemy.atk - t.def);
    if(t.hp<=0) t.alive=false;

    if(!party.some(c=>c.alive)){
      clearInterval(it);
      reviveParty();
      end();
    }
    updateUI();
  },800/speed);
}

/* ===== 進行 ===== */
function stepDungeon(){
  distance += 10;
  currentEnemy = new Enemy(distance);
  updateEnemyUI();
  battle(currentEnemy, ()=>{
    saveGame();
    updateUI();
  });
}

/* ===== UI ===== */
function updateUI(){
  document.getElementById("distance").textContent=distance;
  document.getElementById("rebirth").textContent=rebirthCount;
  const p=document.getElementById("party");
  p.innerHTML="";
  party.forEach((c,i)=>{
    const d=document.createElement("div");
    d.className=c.alive?"":"dead";
    d.textContent=
      `#${i+1} Lv${c.level} HP ${c.hp}/${c.maxHp} 武器${c.weapon.rarity}`;
    p.appendChild(d);
  });
}

function updateEnemyUI(){
  if(!currentEnemy) return;
  document.getElementById("enemyText").textContent=
    `HP ${currentEnemy.hp}/${currentEnemy.maxHp}`;
  document.getElementById("enemyHpBar").style.width=
    (currentEnemy.hp/currentEnemy.maxHp*100)+"%";
}

/* ===== 操作 ===== */
function toggleAuto(){
  if(autoTimer){
    clearInterval(autoTimer);
    autoTimer=null;
  }else{
    autoTimer=setInterval(stepDungeon,3000/speed);
  }
}
function setSpeed(v){
  speed=v;
  if(autoTimer){
    clearInterval(autoTimer);
    autoTimer=setInterval(stepDungeon,3000/speed);
  }
}
function rebirth(){
  rebirthCount++;
  distance=0;
  party=Array.from({length:5},()=>new Character());
  updateUI();
}
function resetGame(){
  localStorage.removeItem("autoRPG_save");
  location.reload();
}

/* ===== セーブ ===== */
function saveGame(){
  localStorage.setItem("autoRPG_save",
    JSON.stringify({distance,rebirthCount,party})
  );
}
function loadGame(){
  const r=localStorage.getItem("autoRPG_save");
  if(!r) return;
  const d=JSON.parse(r);
  distance=d.distance;
  rebirthCount=d.rebirthCount;
  party=d.party.map(p=>Object.assign(new Character(),p));
}

/* ===== 起動 ===== */
loadGame();
updateUI();
</script>